// DP 同 剑指Offer 19题

// 状态表示
// f[i][j] 表示 s[1 ~ i] 和 p[1 ~ j] 是否匹配，则答案为：f[n][m]（n 和 m 表示字符串 s 和 p 的长度）

// 状态计算
// 1、若 p[j] != '*'
//    (1) p[j] == '.', 由于 '.' 可以替换成 s[i], 则 s[1 ~ i - 1] 匹配 p[1 ~ j - 1] 时，可以匹配 
//        f[i][j] = (p[j] == '.') && (f[i - 1][j - 1])
//    (2) p[j] == 'a', 则只有 p[j] == s[i] 且 s[1 ~ i - 1] 匹配 p[1 ~ j - 1] 时，可以匹配 
//        f[i][j] = (s[i] == p[j]) && (f[i - 1][j - 1])

// 综上分析：f[i][j] = (s[i] == p[j] || p[j] == '.') && f[i - 1][j - 1]

// 2、若 p[j] == '*'
//    (1) 若 p[j - 1]p[j] 匹配 s 中的 ""，则 s[1 ~ i] 匹配 p[1 ~ j - 2] 时，可以匹配
//        f[i][j] = f[i][j - 2]
//    (2) 若 p[j - 1]p[j] 匹配 s[i] == "a", 则 p[j - 1] == s[i] 或 '.' 且 s[1 ~ i - 1] 匹配 p[1 ~ j - 2] 时，可以匹配 
//        f[i][j] = (s[i] == p[j - 1] || p[j - 1] == '.') && (f[i - 1][j - 2])
//    (3) 若 p[j - 1]p[j] 匹配 s[i - 1]s[i] == "aa", 则 p[j - 1] == s[i] == s[i - 1] 或 '.' 且 s[1 ~ i - 2] 匹配 p[1 ~ j - 2] 时，可以匹配 
//        f[i][j] = (s[i] == p[j - 1] || s[i - 1] == p[j - 1] || p[j - 1] == '.') && (f[i - 2][j - 2])
//    (4) 以此类推

// 综上分析：f[i][j] = f[i][j - 2]  ||  (s[i] == p[j - 1] || p[j - 1] == '.') && (f[i - 1][j - 2])  ||  (s[i] == p[j - 1] || s[i - 1] == p[j - 1] || p[j - 1] == '.') && (f[i - 2][j - 2])

// 将 p[j - 1] == '.' 提到外边先不考虑：
//          f[i][j] = f[i][j - 2]  ||  (s[i] == p[j - 1]) && (f[i - 1][j - 2])  ||  (s[i] == p[j - 1] || s[i - 1] == p[j - 1]) && (f[i - 2][j - 2])
// 则   f[i - 1][j] =                                         f[i - 1][j - 2]                         || s[i - 1] == p[j - 1]  &&  f[i - 2][j - 2]                   
// 化简得到：
//          f[i][j] = f[i][j - 2] || (s[i] == p[j - 1]) && f[i - 1][j]  
// 再把 p[j - 1] == '.' 放回来：
//          f[i][j] = f[i][j - 2] || (s[i] == p[j - 1] || p[j - 1] == '.') && f[i - 1][j]  



class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(); // s 串的长度
        int m = p.size(); // p 串的长度

        // 为了方便，让两个串的下标从 1 开始
        s = ' ' + s;
        p = ' ' + p;
        // 定义状态数组
        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));
        // 初始化
        f[0][0] = true; // 两个空串是匹配的 

        // 状态转移
        // s 串要从 0 开始，因为 s 串如果是空，'' 是匹配 'a*' 的，但是 p 串如果是空的就不能匹配 s 串，所以 p 串从 1 开始
        for (int i = 0; i <= n; i ++ ) {
            for (int j = 1; j <= m; j ++ ) {
                // p[j] 不是'*'，那就要和 p[j] 匹配
                if (p[j] != '*')
                    f[i][j] = (s[i] == p[j] || p[j] == '.') && (i > 0 && f[i - 1][j - 1]);
                // p[j] 是'*'，那么 p[j - 1] 可以重复若干次，这里用前面说的优化
                else if (p[j] == '*')
                    f[i][j] = f[i][j - 2] || (s[i] == p[j - 1] || p[j - 1] == '.') && (i > 0 && f[i - 1][j]);
            }
        }
        return f[n][m];
    }
};



// 无注释版本

class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size();
        int m = p.size();

        s = ' ' + s;
        p = ' ' + p;
        
        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));

        f[0][0] = true; 

        for (int i = 0; i <= n; i ++ ) {
            for (int j = 1; j <= m; j ++ ) {
                if (p[j] != '*') {
                    f[i][j] = (s[i] == p[j] || p[j] == '.') && (i > 0 && f[i - 1][j - 1]);
                }

                else if (p[j] == '*') {
                    f[i][j] = f[i][j - 2] || (s[i] == p[j - 1] || p[j - 1] == '.') && (i > 0 && f[i - 1][j]);
                }
            }
        }
        return f[n][m];
    }
};

