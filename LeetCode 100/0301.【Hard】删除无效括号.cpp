// 合法的括号序列需满足的两条性质：
// 1、左右括号数相等
// 2、任意前缀中，左括号数 >= 右括号数

// l 表示左括号减右括号的数量，也就是要删除的左括号数量
// r 表示要删掉的右括号数量

// 从头开始枚举，如果遇到左括号了，则左括号数量 +1，l ++
// 如果遇到右括号了，那么要判断一下
// 如果此时左括号 = 右括号，则再加这个右括号就是不合法的了，这个时候就可以删掉这个右括号 r ++
// 如果此时左括号 > 右括号，则左括号数量 -1， l --
// 如果枚举完，栈不为空，则还有剩余的左括号，那么就说明这些左括号是多余的，就把这些左括号删除掉

// 因为要求所有方案，所以就是从前往后枚举，遇到括号就看一下它能不能删除掉，删掉的左括号数量不能超过 l, 删掉右括号的数量不能超过 r
// 还要注意，如果序列里面有多个连续的左括号或者多个连续的右括号，那么这几个连续的括号里面不管删除掉哪个括号结果都是一样的，这个时候就有重复方案了。
// 所以可以人为规定一个顺序，从前往后删除。所以有多个连续的括号的时候，不是去枚举删除哪些括号，而是去枚举删除几个括号（都一定是从前往后删除）

class Solution {
public:
    vector<string> res; // 存所有方案

    vector<string> removeInvalidParentheses(string s) {
        // l 表示当前左括号数量减去右括号数量，r 表示当前要删除掉多少个右括号
        int l = 0, r = 0;
        // 从前往后枚举每一个字符
        for (auto x: s) {
            if (x == '(') l ++ ;
            else if (x == ')') {
                // 如果当前左括号 = 右括号，那么就要删除这个右括号
                if (l == 0) r ++ ; // 要删除的右括号数量 + 1
                // 如果当前左括号 > 右括号，那么就要删除这个左括号
                else l -- ;
            }
        } // 循环结束后，l 就表示一共要删除的左括号的数量，r 就表示一共要删除的右括号的数量


        // 字符串，当前枚举下标，当前删完之后剩余的字符串是什么，当前左括号减去右括号的数量，当前可以删除多少左括号，当前可以删除多少右括号
        dfs(s, 0, "", 0, l, r);
        return res;
    }

    void dfs(string s, int idx, string path, int cnt, int l, int r) {
        // 递归出口，如果已经枚举到了字符串结尾了
        if (idx == s.size()) {
            // 如果满足当前左括号减去右括号的数量是0，就记录当前的答案
            if (cnt == 0) res.push_back(path);
            return;
        }
        // 如果当前的字符既不是左括号，也不是右括号，那么当前的字符是不能删除掉的
        if (s[idx] != '(' && s[idx] != ')')
            dfs(s, idx + 1, path + s[idx], cnt, l, r); // 把当前字符放到path里，然后从下一个字符开始搜
        // 如果当前字符是左括号
        else if (s[idx] == '(') {
            // 看一下当前有多少连续的左括号
            int k = idx;
            while (k < s.size() && s[k] == '(')
                k ++ ;
            // 当前连续的左括号数量就是k - u，先枚举把这些左括号都删除掉的情况
            l -= k - idx;
            // 枚举要删除掉多少个左括号，即枚举删除k - u个直到删除0的情况
            for (int i = k - idx; i >= 0; i -- ) {
                // 如果删掉的左括号数量没有超过l的限制
                if (l >= 0) dfs(s, k, path, cnt, l, r);
                // 根据这个循环的语义，每一轮要把左括号加回来一个
                // 每当加回来一个左括号，左括号减去右括号的差值也要加1，当前可以删除的左括号数量也要加回来1个
                path += '(';
                cnt ++, l ++ ;
            }
        }
        // 如果当前字符是右括号，也是类似的处理
        else {
            int k = idx;
            while (k < s.size() && s[k] == ')')
                k ++ ;
            r -= k - idx;
            for (int i = k - idx; i >= 0; i -- ) {
                // 注意这里删除过多的右括号可能导致cnt小于0，所以这里要约束一下cnt也是>=0的
                if (cnt >= 0 && r >= 0) dfs(s, k, path, cnt, l, r);
                path += ')';
                cnt --, r ++ ;
            }
        }
    }
};